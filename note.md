mmap 和 munmap 系统调用允许 UNIX 程序对其地址空间进行详细控制。它们可用于在进程间共享内存，将文件映射到进程地址空间，以及作为用户级页面故障方案的一部分，如讲座中讨论的垃圾回收算法。

mmap 的调用方式有很多种，但本实验室只需要其与文件内存映射相关的部分功能。你可以假设 addr 始终为 0，这意味着内核将决定映射文件的虚拟地址。mmap 返回该地址，如果失败，则返回 0xffffffffffffffffff。prot 表示内存是否应被映射为可读、可写和/或可执行；可以假定 prot 为 PROT_READ 或 PROT_WRITE，或两者兼而有之。 flags 为 MAP_SHARED，表示对映射内存的修改应写回文件，或 MAP_PRIVATE，表示不应写回文件。fd 是要映射的文件的打开文件描述符。可以假设偏移量为零（这是要映射的文件的起点）。

munmap(addr, length) 应删除指定地址范围内的 mmap 映射。如果进程修改了内存并将其映射为 MAP_SHARED，则应首先将修改内容写入文件。调用 munmap 可能只涉及已映射区域的一部分，但可以假设它将在开始、结束或整个区域取消映射（但不会在区域中间打洞）。

实现步骤:

以下是针对该实验提示的逐步实现思路和关键点解析：

### **1. 初始设置**

- **添加系统调用**：
  - 在 `UPROGS` 中加入 `_mmaptest`。
  - 实现 `mmap` 和 `munmap` 系统调用的空壳（初始返回错误），确保 `user/mmaptest.c` 能编译通过。
  - 权限标志（`PROT_READ` 等）已在 `kernel/fcntl.h` 中定义。

---

### **2. 惰性分配（Lazy Allocation）**

- **核心思想**：`mmap` 不立即分配物理内存或读取文件，而是在发生缺页异常（page fault）时处理。
- **实现步骤**：
  1. 修改 `usertrap()`（在 `kernel/trap.c` 中），检测缺页异常（`scause=13或15`）。
  2. 检查缺页地址是否在某个 VMA 映射范围内。
  3. 若在范围内，分配物理页，用 `readi` 从文件读取数据到该页，并建立页表映射。

---

### **3. 管理 VMA（Virtual Memory Area）**

- **进程关联**：
  - 在 `struct proc` 中增加固定大小的 VMA 数组（如 `struct vma vmas[16]`）。
  - `mmap` 调用时，找到一个空闲 VMA 并初始化。

---

### **4. 实现 `mmap`**

- **步骤**：
  1. 在用户地址空间中找到空闲区域（参考 `lazyalloc` 实验的地址选择逻辑）。
  2. 填充一个 VMA 条目，记录映射参数。
  3. 增加文件的引用计数（`filedup` 防止文件被提前关闭）。
- **注意**：
  - 不实际分配内存或读取文件。
  - 返回映射的起始虚拟地址。

---

### **5. 处理缺页异常**

- **流程**：
  1. 在 `usertrap` 中捕获缺页异常。
  2. 遍历进程的 VMA 数组，确定缺页地址是否属于某个映射。
  3. 若属于：
     - 分配物理页（`kalloc`）。
     - 用 `readi` 从文件的 `offset + (addr - vma.addr)` 处读取 4KB 数据。
     - 建立页表映射（`mappages`），设置正确的权限（如 `PTE_U | PTE_R`）。

---

### **6. 实现 `munmap`**

- **步骤**：
  1. 找到覆盖目标地址范围的 VMA。
  2. 使用 `uvmunmap` 解除页表映射。
     - 若页面被修改且为 `MAP_SHARED`，写回文件（模仿 `filewrite`）。
  3. 若整个 VMA 被解除，减少文件的引用计数（`fileclose`）。
- **注意**：
  - 无需检查 PTE 的 dirty bit（D 位），直接写回所有页面即可（根据提示简化）。

---

### **7. 修改 `exit` 和 `fork`**

- **exit**：
  - 遍历所有 VMA，调用 `munmap` 解除映射并释放资源。
- **fork**：
  - 复制父进程的 VMA 数组到子进程。
  - 对每个 VMA 中的文件调用 `filedup` 增加引用计数。
  - 子进程的页表延迟分配，无需共享父进程的物理页。

---

### **8. 测试与调试**

- **逐步验证**：
  1. `mmaptest` 应通过 `mmap_test`。
  2. 实现写回后通过 `fork_test`。
  3. 最后运行 `usertests` 确保其他功能正常。

---

### **关键挑战与解决方案**

| **问题** | **解决思路**                                                                 |
| -------------- | ---------------------------------------------------------------------------------- |
| 缺页异常处理   | 在 `usertrap` 中识别 VMA 并加载文件数据。                                        |
| 文件引用计数   | `mmap` 时 `filedup`，`munmap` 或 `exit` 时 `fileclose`。                 |
| 地址对齐       | 确保 `mmap` 的 `offset` 和 `addr` 按页对齐（如 4096 字节）。                 |
| 写回文件       | 在 `munmap` 或 `exit` 时，若为 `MAP_SHARED` 则调用 `writei` 写回修改的页。 |


`MAP_SHARED` 和 `MAP_PRIVATE` 是 Linux 内存映射（`mmap`）系统调用中的两种常用标志，用于控制进程对映射内存的访问和修改行为。它们的主要区别如下：

### **1. `MAP_SHARED`（共享映射）**

- **作用**：创建一个**共享映射**，对映射内存的修改会**同步到文件**（如果映射的是文件），并且其他映射了同一文件的进程**可见**这些修改。
- **特点**：
  - **写入会反映到文件**：修改内存后，文件内容也会更新（除非使用 `msync` 显式同步，否则可能不会立即写入磁盘）。
  - **进程间共享**：多个进程映射同一文件时，可以通过共享内存通信。
  - **用途**：
    - 进程间通信（IPC）。
    - 对文件进行读写（如内存映射文件 I/O）。
- **示例**：
  ```c
  int fd = open("file.txt", O_RDWR);
  void *addr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
  ```

---

### **2. `MAP_PRIVATE`（私有映射）**

- **作用**：创建一个**私有映射**，对内存的修改**不会同步到文件**，且其他进程不可见。修改时会触发**写时复制（Copy-on-Write, COW）**，即修改的内容仅为当前进程私有。
- **特点**：
  - **写入不影响文件**：修改仅存在于内存中，文件内容不变。
  - **进程隔离**：其他进程（即使是映射同一文件的进程）看不到当前进程的修改。
  - **用途**：
    - 加载只读文件（如程序代码段）。
    - 需要修改文件数据但不想影响原文件时（如动态链接库的局部修改）。
- **示例**：
  ```c
  int fd = open("file.txt", O_RDONLY);
  void *addr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
  ```

---

### **关键区别**

| 特性                         | `MAP_SHARED`             | `MAP_PRIVATE`            |
| ---------------------------- | -------------------------- | -------------------------- |
| **修改是否同步到文件** | 是                         | 否（写时复制）             |
| **进程间可见性**       | 其他进程可见               | 仅当前进程可见             |
| **典型用途**           | 进程间通信、文件持久化修改 | 只读文件加载、私有数据修改 |

---

### **其他注意事项**

1. **文件描述符权限**：

   - 使用 `MAP_SHARED` 时，文件必须**可写**（`O_RDWR` 或 `O_WRONLY`）。
   - `MAP_PRIVATE` 只需文件可读（即使指定了 `PROT_WRITE`）。
2. **匿名映射**：若映射的不是文件（通过 `fd = -1`），`MAP_SHARED` 仍可在父子进程间共享内存，而 `MAP_PRIVATE` 会创建私有内存。
3. **性能**：
   `MAP_PRIVATE` 可能因写时复制产生额外开销，但初始映射更快（无需同步文件）。

### **总结**

- 需要**跨进程共享数据**或**修改文件** → 用 `MAP_SHARED`。
- 需要**私有数据副本**或**只读访问** → 用 `MAP_PRIVATE`。
